module Video where

import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Word (Word32, Word64)
import SDL.FFI
import SDL.Prelude
import Vec
import Prelude hiding (lookup)

data Video = Video
  { window :: SDLWindow,
    renderer :: ImageRenderer,
    font :: FontRenderer
  }

type AtlasMap = Map AtlasName Atlas

data ImageRenderer = ImageRenderer
  { renderer :: SDLRenderer,
    atlasMap :: AtlasMap
  }

data FontRenderer = FontRenderer
  { textEngine :: SDLTextEngine,
    smallFont :: SDLFont,
    mediumFont :: SDLFont
  }

initRenderer :: SDLWindow -> IO ImageRenderer
initRenderer window = do
  renderer <- sdlRenderer window
  return ImageRenderer {renderer, atlasMap = Map.empty}

fontPath :: String
fontPath = "data/font/courier.ttf"

initFont :: SDLRenderer -> IO FontRenderer
initFont renderer = do
  textEngine <- sdlCreateTextEngine renderer
  smallFont <- sdlOpenFont fontPath 12
  mediumFont <- sdlOpenFont fontPath 20
  return
    FontRenderer
      { textEngine,
        smallFont,
        mediumFont
      }

initVideo :: IO Video
initVideo = do
  window <- sdlWindow "app" 800 600 0
  renderer <- initRenderer window
  font <- initFont renderer.renderer
  return
    Video
      { window,
        renderer,
        font
      }

class Drawable a where
  draw :: a -> Video -> IO Video

data AtlasName = ZlukAtlas deriving (Eq, Ord, Enum)

type AtlasSize = V2 Float

type AtlasIdx = V2 Float

data Atlas = Atlas
  { texture :: SDLTexture,
    w :: Float,
    h :: Float
  }
  deriving (Eq, Show)

imageBasePath :: String
imageBasePath = "data/image/"

loadAtlas :: SDLRenderer -> String -> AtlasSize -> IO Atlas
loadAtlas renderer name (V2 w h) = do
  texture <- sdlLoadPngTexture renderer (imageBasePath ++ name ++ ".png")
  return Atlas {texture, w, h}

loadAtlasByName :: SDLRenderer -> AtlasName -> IO Atlas
loadAtlasByName renderer i = case i of
  ZlukAtlas -> load "zluk" (V2 64 64)
  where
    load = loadAtlas renderer

loadAtlasByNameCached :: ImageRenderer -> AtlasName -> IO (ImageRenderer, Atlas)
loadAtlasByNameCached ir@ImageRenderer {..} atlasId =
  case Map.lookup atlasId atlasMap of
    Just atlas -> return (ir, atlas)
    Nothing -> do
      atlas <- loadAtlasByName renderer atlasId
      return (ir {atlasMap = Map.insert atlasId atlas atlasMap}, atlas)

atlasSrcFRect :: Float -> Float -> Float -> Float -> FRect
atlasSrcFRect w h xIdx yIdx = V4 (xIdx * w) (yIdx * h) w h

renderFromAtlas :: SDLRenderer -> Atlas -> AtlasIdx -> FPoint -> IO ()
renderFromAtlas renderer Atlas {..} (V2 xIdx yIdx) (V2 dstX dstY) = do
  let srcRect = atlasSrcFRect w h xIdx yIdx
  let dstRect = V4 dstX dstY w h
  sdlRenderTexture renderer texture srcRect dstRect

renderFromCachedAtlasById :: ImageRenderer -> AtlasName -> AtlasIdx -> FPoint -> IO ImageRenderer
renderFromCachedAtlasById ir atlasName atlasIdx dst = do
  (ir', atlas) <- loadAtlasByNameCached ir atlasName
  renderFromAtlas ir'.renderer atlas atlasIdx dst
  return ir'

goldenAnimationFrame3 :: Float -> Float
goldenAnimationFrame3 t | 
  

-- goldenAnimation :: Word64 -- ^ number of animation frames
--                 -> SDLDuration -- ^ animation sequence duration
--                 -> SDLTick -- ^ time offset
--                 -> SDLTick -- ^ current time
--                 -> Word64 -- ^ 
-- goldenAnimation subFrames toff tnow frameDuration  =
--    let tframe = (tnow - toff) `mod` frameDuration
       
      
-- zlukAtlasIdx :: Word64 -> Word64 -> FPoint
-- zlukAtlasIdx toff tnow =
--   let t = tnow - toff
--       f = realToFrac ((t `mod` second) `div` zlukFrame)
--    in if f < 3
--         then V2 (2 - f) 0
--         else V2 (f - 3) 0

-- zlukScreenPos :: Word64 -> Word64 -> FPoint
-- zlukScreenPos toff tnow =
--   let t = tnow - toff
--       y = 200
--       f = (t `div` (8*seconds))
--       x = if f < 4*seconds
--           then 100 + 600* ((realToFrac f) / 4*seconds)
--           else 700 - 600 * (realToFrac 
